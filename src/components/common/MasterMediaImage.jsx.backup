import { useMemo, useRef } from "react";
import { resolveMediaPath } from "../../utils/mediaManifest.js";

const loggedKeys = new Set();

/**
 * Extracts filename from remote URL or file object
 */
function extractFilename(file, remoteSrc) {
  // Try file object properties first
  if (file?.name) return file.name;
  if (file?.title) return file.title;
  
  // Extract from remote URL
  if (!remoteSrc) return null;
  try {
    const url = new URL(remoteSrc);
    const last = url.pathname.split("/").pop();
    return last ? decodeURIComponent(last) : null;
  } catch {
    const last = remoteSrc.split("/").pop();
    return last ? decodeURIComponent(last) : null;
  }
}

/**
 * ============================================
 * MasterMediaImage â€“ ONE IMAGE ELEMENT
 * ============================================
 * 
 * Accepts:
 * - file: Noco file object { name, signedPath, path, ... }
 * - filename: explicit filename override
 * - remoteSrc: explicit remote URL override
 * 
 * Logic:
 * 1. Extract filename from file object or URL
 * 2. Check if file exists in local /media via manifest
 * 3. If yes â†’ use local version
 * 4. If no â†’ use remoteSrc (NocoDB fallback)
 * 5. If both fail â†’ return null
 */
export default function MasterMediaImage({
  file,
  filename,
  remoteSrc,
  alt = "",
  className = "",
  style,
  loading = "lazy",
  decoding = "async",
  onLoad,
  onError: externalOnError,
}) {
  const NOCO = import.meta.env.VITE_NOCO_BASE_URL || "http://localhost:8080";
  const triedFallback = useRef(false);

  // â­ Compute sources
  const computed = useMemo(() => {
    // 1. Get the filename from file object, explicit filename, or remote URL
    const rawFilename = filename || extractFilename(file, remoteSrc);

    // 2. Determine remote URL
    let computedRemoteSrc = remoteSrc;
    if (!computedRemoteSrc && file) {
      const path = file.signedPath || file.path || file.thumbnails?.card_cover?.signedPath;
      if (path) {
        computedRemoteSrc = `${NOCO}/${path}`;
      }
    }

    // 3. Resolve local path using manifest (handles normalization internally)
    const localSrc = rawFilename ? resolveMediaPath(rawFilename) : null;

    // 4. Determine primary & secondary sources
    const primary = localSrc || computedRemoteSrc || "";
    const secondary = localSrc && computedRemoteSrc && primary !== computedRemoteSrc ? computedRemoteSrc : null;

    return { rawFilename, localSrc, computedRemoteSrc, primary, secondary };
  }, [file, filename, remoteSrc, NOCO]);

  // â­ Debug logging
  if (typeof import.meta !== "undefined" && import.meta.env?.DEV) {
    const key = `${computed.rawFilename || ""}|${computed.primary}|${computed.secondary || ""}`;
    if (!loggedKeys.has(key)) {
      loggedKeys.add(key);
      console.log("ðŸŽ¨ MasterMediaImage", {
        filename: computed.rawFilename,
        hasLocal: !!computed.localSrc,
        hasRemote: !!computed.computedRemoteSrc,
        primary: computed.primary,
        secondary: computed.secondary,
      });
    }
  }

  // â­ Handle image errors
  const handleError = (e) => {
    if (!triedFallback.current && computed.secondary) {
      triedFallback.current = true;
      console.warn("ðŸ“¸ Fallback to remote:", computed.rawFilename || computed.computedRemoteSrc);
      e.currentTarget.src = computed.secondary;
      return;
    }
    externalOnError?.(e);
  };

  // If no valid source, return null
  if (!computed.primary) {
    if (import.meta.env?.DEV) {
      console.warn("ðŸš« MasterMediaImage: No valid source", { file, filename, remoteSrc });
    }
    return null;
  }

  return (
    <img
      src={computed.primary}
      alt={alt}
      className={className}
      style={style}
      loading={loading}
      decoding={decoding}
      onError={handleError}
      onLoad={onLoad}
    />
  );
}
